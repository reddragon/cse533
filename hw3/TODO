Return value of odr_queue_or_send_rrep() is unused, but it needs to be
used to send the RREP again if necessary.

When we send and RREQ for a RREP that we might send, we set the flag
currently irrespective of whether we queued or sent the RREP. Fix this.

We send an RREP followed b yand RREQ. Check if this is in violation
with anything mentioned in the handout.


-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*

Re-try 2 times in the client.
Set the rediscovery flag in the 2nd transmission.
Check if rediscovery is actually kicking off rediscovery.

-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*

Read document to see where we need to perform hostname <-> IP Address
conversions.

Print out trace messages with VM names instead of IP addresses.

-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*

Do NOT propagate RREQ if we send an RREP unless this RREQ replaced an
existing path in our routing table.

"Unlike AODV, when an intermediate node receives a RREQ for which it
generates a RREP, it should nevertheless continue to flood the RREQ it
received if the RREQ pertains to a source node whose existence it has
heretofore been unaware of, or the RREQ gives it a more efficient
route than it knew of back to the source node (the reason for
continuing to flood the RREQ is so that other nodes in the intranet
also become aware of the existence of the source node or of the
potentially more optimal reverse route to it, and update their tables
accordingly)."

-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*

Aravind's bug: RREPs should have destination address of RREQ as the
source address, and NOT the address of the machine sending the RREP.

-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
